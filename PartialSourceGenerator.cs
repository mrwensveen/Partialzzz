using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Partialzzz
{

    [Generator]
    public class PartialSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            string source = $@"// <auto-generated/>
using System;

namespace Partialzzz
{{
    public class Partialzzz<T> where T : class {{ }}
}}
";

            context.RegisterPostInitializationOutput(ctx =>
                ctx.AddSource("Partialzzz.g.cs", SourceText.From(source, Encoding.UTF8))
            );

            // Filter all Partialzzz<T> subclasses
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: IsSyntaxTargetForGeneration,
                    transform: Transform
                )!;

            // Combine the selected classes with the Compilation
            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
                = context.CompilationProvider.Combine(classDeclarations.Collect());

            // Generate the source using the compilation and classes
            context.RegisterSourceOutput(compilationAndClasses,
                static (spc, source) => Execute(spc, source.Item1, source.Item2));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode s, CancellationToken _) =>
            s is ClassDeclarationSyntax c
            && c.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
            && c.BaseList?.Types.FirstOrDefault()?.Type.ToString().Contains("Partialzzz") == true;

        private static ClassDeclarationSyntax Transform(GeneratorSyntaxContext ctx, CancellationToken _) =>
            (ctx.Node as ClassDeclarationSyntax)!;

        private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes)
        {
            if (classes.IsDefaultOrEmpty)
            {
                // nothing to do yet
                return;
            }

            // generate the source code and add it to the output

            // TODO: Generate all classes from the same namespace in the same ns declaration

            string result = $@"#nullable enable
// <auto-generated/>
using System;

{string.Join("", classes.Select(cds => GenerateImpl(context, compilation, cds)))}

";

            context.AddSource("PartialzzzImpl.g.cs", SourceText.From(result, Encoding.UTF8));
        }

        private static string GenerateImpl(SourceProductionContext context, Compilation compilation, ClassDeclarationSyntax classDeclaration)
        {
            var type = compilation.GetTypeByMetadataName($"{GetNamespaceFrom(classDeclaration)}.{classDeclaration.Identifier}");
            var generic = type?.BaseType?.TypeArguments[0];

            var properties = generic != null
                ? compilation.GetTypeByMetadataName(generic.ToString())?.GetMembers().Where(symbol => symbol.Kind == SymbolKind.Property)
                : Enumerable.Empty<ISymbol>();

            // TODO: Only select non-nullable (required?) (reference type?) properties
            // TODO: Emit the proper type of the property

            string impl = $@"
namespace {GetNamespaceFrom(classDeclaration)}
{{
    partial class {classDeclaration.Identifier}
    {{
        {string.Join("", properties.Select(p => $@"
        public string? {p.Name} {{ get; set; }}
"))}
    }}
}}
";

            return impl;
        }

        public static string GetNamespaceFrom(SyntaxNode s) => s.Parent switch
        {
            NamespaceDeclarationSyntax namespaceDeclarationSyntax => namespaceDeclarationSyntax.Name.ToString(),
            null => string.Empty, // or whatever you want to do
            _ => GetNamespaceFrom(s.Parent)
        };
    }
}
